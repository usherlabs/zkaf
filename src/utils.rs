use elliptic_curve::pkcs8::DecodePublicKey;
use tlsn_core::proof::{SessionProof, TlsProof};

/// A simple verifier which reads a proof generated by `simple_prover.rs` from "proof.json", verifies
/// it and prints the verified data to the console.
pub fn verify_proof(proof: &String, pub_key: &String) -> Result<String, String> {
    // Deserialize the proof
    let proof: TlsProof =
        serde_json::from_str(proof.as_str()).or(Err("INVALID PROOF".to_owned()))?;

    let TlsProof {
        // The session proof establishes the identity of the server and the commitments
        // to the TLS transcript.
        session,
        // The substrings proof proves select portions of the transcript, while redacting
        // anything the Prover chose not to disclose.
        substrings,
    } = proof;

    // Verify the session proof against the Notary's public key
    //
    // This verifies the identity of the server using a default certificate verifier which trusts
    // the root certificates from the `webpki-roots` crate.
    let pub_key = p256::PublicKey::from_public_key_pem(pub_key.as_str())
        .or(Err("INVALID PUBLIC KEY".to_owned()))?;
    session
        .verify_with_default_cert_verifier(pub_key)
        .or(Err("INVALID PUBLIC KEY".to_owned()))?;

    let SessionProof {
        // The session header that was signed by the Notary is a succinct commitment to the TLS transcript.
        header,
        // This is the server name, checked against the certificate chain shared in the TLS handshake.
        // server_name,
        ..
    } = session;

    // Verify the substrings proof against the session header.
    //
    // This returns the redacted transcripts
    let (mut sent, mut recv) = substrings
        .verify(&header)
        .or(Err("PROOF VERIFICATION FAILED".to_string()))?;

    // Replace the bytes which the Prover chose not to disclose with 'X'
    sent.set_redacted(b'X');
    recv.set_redacted(b'X');

    // concatenate the request and response and log it to stdout
    let req_res = format!(
        "{}{}",
        String::from_utf8(recv.data().to_vec()).unwrap(),
        String::from_utf8(sent.data().to_vec()).unwrap()
    );

    Ok(req_res)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_verify_proof() {
        let proof = std::fs::read_to_string("test/mock.json").unwrap();
        let pem_file = "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEBv36FI4ZFszJa0DQFJ3wWCXvVLFr\ncRzMG5kaTeHGoSzDu6cFqx3uEWYpFGo6C0EOUgf+mEgbktLrXocv5yHzKg==\n-----END PUBLIC KEY-----\n";

        let req_res_pair = verify_proof(&proof, &pem_file.to_string()).unwrap();
        println!("{}", req_res_pair);
        assert!(req_res_pair.starts_with("HTTP"))
    }
}
